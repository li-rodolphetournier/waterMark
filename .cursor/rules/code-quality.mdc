---
description: RÃ¨gles de qualitÃ© de code et bonnes pratiques gÃ©nÃ©rales
globs: ["**/*.py", "**/*.spec"]
alwaysApply: true
---

# âœ¨ QualitÃ© de Code et Best Practices

## ğŸ¯ Principes SOLID

### Single Responsibility
- Une classe = une responsabilitÃ©
- Une fonction = une tÃ¢che
- SÃ©parer GUI / Logique / IO

### Open/Closed
- Classes extensibles mais fermÃ©es Ã  la modification
- Utiliser l'hÃ©ritage et la composition

### DRY (Don't Repeat Yourself)
- Factoriser le code dupliquÃ©
- CrÃ©er des fonctions utilitaires rÃ©utilisables

## ğŸ“ Documentation

### Docstrings (Google Style)
```python
def apply_watermark(image_path: str, text: str, opacity: float = 0.5) -> bool:
    """Applique un watermark sur une image.
    
    Args:
        image_path: Chemin vers l'image source
        text: Texte du watermark
        opacity: Transparence entre 0.0 et 1.0
        
    Returns:
        True si le watermark a Ã©tÃ© appliquÃ© avec succÃ¨s
        
    Raises:
        FileNotFoundError: Si l'image n'existe pas
        ValueError: Si l'opacitÃ© est hors limites
    """
```

### Commentaires
- Commenter le **pourquoi**, pas le **quoi**
- Ã‰viter les commentaires Ã©vidents
- Mettre Ã  jour les commentaires avec le code

## ğŸ”„ Refactoring

### Quand Refactoriser
- Code dupliquÃ© > 3 fois
- Fonction > 50 lignes
- Classe > 300 lignes
- ComplexitÃ© cyclomatique > 10

### Patterns Ã  Ã‰viter
```python
# âŒ Magic numbers
if opacity > 0.5:
    ...

# âœ… Constantes nommÃ©es
OPACITY_THRESHOLD = 0.5
if opacity > OPACITY_THRESHOLD:
    ...

# âŒ Conditions imbriquÃ©es profondes
if a:
    if b:
        if c:
            ...

# âœ… Early return
if not a:
    return
if not b:
    return
if not c:
    return
...
```

## ğŸ§ª Tests

### Structure des Tests
```python
def test_nom_fonction_cas_specifique():
    # Arrange
    input_data = "..."
    
    # Act
    result = fonction(input_data)
    
    # Assert
    assert result == expected
```

### Couverture Minimale
- Fonctions critiques : 100%
- Logique mÃ©tier : 80%
- GUI : Tests manuels documentÃ©s

## ğŸš« Anti-Patterns Ã  Ã‰viter

### Code Smells
- **God Class** : Une classe qui fait tout
- **Long Method** : MÃ©thode de plus de 50 lignes
- **Feature Envy** : MÃ©thode qui utilise plus les donnÃ©es d'une autre classe
- **Data Clumps** : Groupes de variables toujours ensemble

### Erreurs Courantes
```python
# âŒ Attraper toutes les exceptions silencieusement
try:
    ...
except:
    pass

# âœ… GÃ©rer les exceptions spÃ©cifiquement
try:
    ...
except FileNotFoundError:
    logger.error("Fichier non trouvÃ©")
except Exception as e:
    logger.exception("Erreur inattendue")
    raise

# âŒ Chemins codÃ©s en dur
font_path = "C:\\Windows\\Fonts\\arial.ttf"

# âœ… Chemins dynamiques
font_path = os.path.join(os.environ["WINDIR"], "Fonts", "arial.ttf")
```

## ğŸ“Š MÃ©triques de Code

### Objectifs
| MÃ©trique | Objectif |
|----------|----------|
| Lignes par fonction | < 50 |
| ParamÃ¨tres par fonction | < 5 |
| Profondeur d'imbrication | < 4 |
| ComplexitÃ© cyclomatique | < 10 |

## ğŸ”§ Configuration

### requirements.txt
```
# Toujours Ã©pingler les versions
pillow>=10.0.0,<11.0.0
pyinstaller>=5.13.0
```

### .gitignore Essentiel
```
# Build
build/
dist/
*.spec
*.exe

# Python
__pycache__/
*.pyc
*.pyo
.pytest_cache/

# IDE
.vscode/
.idea/

# Env
.env
venv/
```

## ğŸ” SÃ©curitÃ©

### DonnÃ©es Sensibles
- NE JAMAIS commiter de secrets
- Utiliser des variables d'environnement
- Valider toutes les entrÃ©es utilisateur

### Fichiers et Chemins
```python
# âœ… Utiliser pathlib pour la manipulation de chemins
from pathlib import Path

base_path = Path(__file__).parent
config_path = base_path / "config" / "settings.json"
```

## ğŸŒ Internationalisation

### PrÃ©paration i18n
```python
# Centraliser les chaÃ®nes de caractÃ¨res
MESSAGES = {
    "error_file_not_found": "Fichier non trouvÃ©",
    "success_watermark": "Watermark appliquÃ© avec succÃ¨s",
}

def get_message(key: str) -> str:
    return MESSAGES.get(key, key)
```
